# 字符串相关
## Manacher
算法应用：求一个字符串的**最长回文字串**，同时这一类问题可以使用**Hash**求解。
```cpp
char s[maxn];
char s_new[2 * maxn];
int p[2 * maxn];

int init()
{
    int len = strlen(s);
    s_new[0] = '$';
    s_new[1] = '#';
    int j = 2;
    for(int i = 0;i < len;i++){
        s_new[j++] = s[i];
        s_new[j++] = '#';
    }
    s_new[j] = '\0';
    return j;
}

int manacher()
{
    int len = init();
    int max_len = 1,id,mx = 0;
    for(int i = 1;i <= len;i++){
        if(i < mx) p[i] = min(p[2 * id - i],mx - i);
        else p[i] = 1;
        while(s_new[i - p[i]] == s_new[i + p[i]]) p[i] ++;
        if(mx < i + p[i]){
            id = i;
            mx = i + p[i];
        }
        max_len = max(max_len,p[i] - 1);
    }
    return max_len;
}

```
## 后缀数组
可以使用Hash + 二分 + 快排的思维去手写，时间复杂度$O(nlog^2{n})$
**例题：**[Ac.Wing 140 后缀数组](https://www.acwing.com/problem/content/description/142/)
一般的做法是倍增或者是`DC3`算法实现，时间复杂度同样还是$O(nlog^2{n})$
```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 1000010;

char s[N];
int n, w, sa[N], rk[N << 1], oldrk[N << 1];
// 为了防止访问 rk[i+w] 导致数组越界，开两倍数组。
// 当然也可以在访问前判断是否越界，但直接开两倍数组方便一些。

int main() {
  int i, p;

  scanf("%s", s + 1);
  n = strlen(s + 1);
  for (i = 1; i <= n; ++i) sa[i] = i, rk[i] = s[i];

  for (w = 1; w < n; w <<= 1) {
    sort(sa + 1, sa + n + 1, [](int x, int y) {
      return rk[x] == rk[y] ? rk[x + w] < rk[y + w] : rk[x] < rk[y];
    });  // 这里用到了 lambda
    memcpy(oldrk, rk, sizeof(rk));
    // 由于计算 rk 的时候原来的 rk 会被覆盖，要先复制一份
    for (p = 0, i = 1; i <= n; ++i) {
      if (oldrk[sa[i]] == oldrk[sa[i - 1]] &&
          oldrk[sa[i] + w] == oldrk[sa[i - 1] + w]) {
        rk[sa[i]] = p;
      } else {
        rk[sa[i]] = ++p;
      }  // 若两个子串相同，它们对应的 rk 也需要相同，所以要去重
    }
  }

  for (i = 1; i <= n; ++i) printf("%d ", sa[i]);

  return 0;
}
```
最后的到的$Sa$数组就是存放了按字典序排好的后缀数组的编号
